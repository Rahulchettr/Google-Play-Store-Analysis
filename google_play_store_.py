# -*- coding: utf-8 -*-
"""Google play store .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TqbVkqFJizNA8khpdWGNDsi7Uux1iY21
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.io as pio
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import webbrowser
import os

app_df= pd.read_csv('Play Store Data.csv')

user_review = pd.read_csv('User Reviews.csv')

app_df

user_review.head()

# df.isnull () : missing value
# df.dropna () : Removes rows and colums that contain the missing value
# df . fillna() : fills missing values
# df . duplicate() : Identifies duplicate
# df . drop_duplicate() :Removes  duplicate rows

app_df = app_df.dropna(subset=['Rating'])
for column in app_df.columns:
    app_df.fillna({column: app_df[column].mode()[0]}, inplace=True)
app_df = app_df.drop_duplicates()
app_df = app_df[app_df['Rating'] <= 5]

app_df.dtypes

user_review.dropna(subset=['Translated_Review'],inplace=True)

app_df['Installs']=app_df['Installs'].str.replace(',','').str.replace('+', '').astype(int)
app_df['Price']=app_df['Price'].str.replace('$','').astype(float)

app_df.dtypes

merged_df=pd.merge(app_df,user_review,on='App',how='inner')

merged_df.head()

#Data Transformation
app_df['Reviews']= app_df['Reviews'].astype(int)

def convert_size (size):
  if isinstance(size, str):
    if 'M'in size:
      return float(size.replace('M',""))
    elif 'K' in size:
      return float(size.replace("k",""))/1024
    else :
     return np.nan
  else:
    return np.nan

app_df['Size']=app_df['Size'].apply(convert_size)

app_df.head()

##Logrimatic
app_df['Log_install']=np.log1p(app_df['Installs'])

app_df['Reviwes']=app_df['Reviews'].astype(int)

app_df['log_Reviews']=np.log1p(app_df['Reviews'])

app_df.dtypes

def rating_group(Rating):
  if Rating >= 4:
    return 'Top rated app'
  elif Rating >= 3:
    return 'Above Rating'
  elif Rating >= 2:
    return 'Average'
  else:
    return 'Below average'
  app_df['Rating_group']=app_df['Rating'].apply(rating_group)

#Revemu coloum
app_df['Revenue']=app_df['Price']*app_df['Installs']

import nltk
nltk.download('vader_lexicon')

sia = SentimentIntensityAnalyzer()

#Polarity Scores in Sia
#Positive, Negative, Neutral And compound -1 Very negative ; +1 - very negative

review = "This app is amazing! I love the new feature"
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

review = "This app is Bad! I hate  the new feature"
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

review = "This app is Okay!"
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

user_review['Sentiment_Score']=user_review['Translated_Review'].apply(lambda x: sia.polarity_scores(str(x))['compound'])

user_review.head()

app_df['Last Updated']=pd.to_datetime(app_df['Last Updated'],errors='coerce')

app_df['Year']=app_df['Last Updated'].dt.year

app_df.head()

import plotly.express as px
fig=px.bar(x=["A","B","C"],y=[1,2,3,],title= "Sample Bar Chart" )

fig.show()

fig.write_html("interactive_plot.html")

#statics Visualization : fixed images or plots,Non interactive
#interative Visualization:

import os

html_files_path="./"
if not os.path.exists(html_files_path):
  os.makedirs(html_files_path)

plot_containers=""

def save_plot_as_html(fig,filename,insight):
  global plot_containers
  filepath=os.path.join(html_files_path,filename)
  html_content=fig.to_html(full_html=False,include_plotlyjs='inline')
  plot_containers += f"""<div class="plot-container" id="{filename}" onclick="openplot('{filename}')">
<div class="plot">{html_content}</div> <div class='insight'>{insight}</div> </div>"""
  fig.write_html(filepath,full_html=False,include_plotlyjs='inline')

plot_width=400
plot_height=300
plot_bgcolor='black'
text_color='white'
title_font={'size':16}
axis_font={'size:12'}

category_counts=app_df['Category'].value_counts().nlargest(10)
fig1=px.bar(
    x=category_counts.index,
    y=category_counts.values,
    labels={'x':'Category', 'y':'count'},
    title='Top categorys on Play Store',
    color=category_counts.index,
    color_discrete_sequence=px.colors.sequential.Plasma,
    width=400,
    height=300

)
fig1.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig1,'Category Graph 1.html',
 "The top categories on the Play Store are dominated bhy tools,entertainment,and productivity apps")

fig1.show()

# Save the plot as HTML file
fig1.write_html("Category_Graph_1.html")

from google.colab import files
files.download("Category_Graph_1.html")

#figure2
type_counts=app_df['Type'].value_counts()
fig2=px.pie(
    values=type_counts.values,
    names=type_counts.index,
    title='App Type Distribution',
    color_discrete_sequence=px.colors.sequential.RdBu,
    width=400,
    height=300

)
fig2.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig2,'Type Graph 2.html',
 "Most apps on the Playstore are free,indicating a strategy to attract user first and monetize through ads or in app purchases ")

fig2.write_html("Type_Graph_2.html")

from google.colab import files
files.download("Type_Graph_2.html")

fig2.show()

#figure 3
fig3=px.histogram(
    app_df,
    x='Rating',
    nbins=20,
    title='Rating Distribution',
    color_discrete_sequence=['#636EFA'],
    width=400,
    height=300

)
fig3.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig3,'Rating Graph 3.html',
 " Rating are skewed towards higher values, suggesting that most app are rated favorably by user")

fig3.write_html("Rating_Graph_3.html")

from google.colab import files
files.download("Rating_Graph_3.html")

fig3.show()

#figure 4
sentiment_counts=user_review['Sentiment_Score'].value_counts()
fig4=px.bar(
    x=sentiment_counts.index,
    y=sentiment_counts.values,
    labels={'x':'Sentiment_Score', 'y':'count'},
    title='Sentimenty Distribution',
    color=sentiment_counts.index,
    color_discrete_sequence=px.colors.sequential.RdPu,
    width=400,
    height=300

)
fig4.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig4,'Sentiment  Graph 4.html',
 "Sentiment in reviews show a mix of positive and negative feedback, with a slight lean towards positive ")

fig4.write_html("Sentiment_Score_Graph_4.html")

from google.colab import files
files.download("Sentiment_Score_Graph_4.html")

fig4.show()

#figure5
installs_by_category=app_df.groupby('Category')['Installs'].sum().nlargest(10)
fig5=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,
    orientation='h',
    labels={'x':'Installs', 'y':'Category'},
    title='Installs by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Blues,
    width=400,
    height=300

)
fig5.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig5,'Installs  Graph 5.html',
 "cThe Categories with the most installs are social and communication apps , reflecting their broad appeal and daily usages  ")

fig5.write_html('installs_by_category_graph 5.html')

from google.colab import files
files.download('installs_by_category_graph 5.html')

fig5.show()

#figure6
updates_per_year=app_df['Last Updated'].dt.year.value_counts().sort_index()
fig6=px.line(
    x=updates_per_year.index,
    y=updates_per_year.values,

    labels={'x':'year', 'y':'Number of Updates'},
    title='Number of Updates over the Years',
    color_discrete_sequence=['#636EFA'],
    width=400,
    height=300

)
fig6.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig6,'Updates Graph 6.html',
 "Updates have been increasing over the years, showing that developes are actively maintaining and improving their apps")

fig6.write_html("updates_per_year_Graph_6.html")

from google.colab import files
files.download("updates_per_year_Graph_6.html")

fig6.show()

#figure7
revenue_by_category=app_df.groupby('Category')['Revenue'].sum().nlargest(10)
fig7=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,

    labels={'x':'Category', 'y':'Revenue'},
    title='Revenue by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Greens,
    width=400,
    height=300

)
fig7.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig7,'Revenue Graph 7.html',
 "Categories such as as Business and productivity lead in revenue generation, indicating their monetization potential")

fig.write_html('revenue_by_category_Graph 7.html')

from google.colab import files
files.download('revenue_by_category_Graph 7.html')

fig7.show()

#figure 8
genre_counts=app_df['Genres'].str.split (',',expand=True).stack().value_counts().nlargest(10)
fig8=px.bar(
    x=genre_counts.index,
    y=genre_counts.values,

    labels={'x':'Genres', 'y':'Count'},
    title='Top Geners',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.OrRd,
    width=400,
    height=300

)
fig8.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig8,'Genres Graph 8.html',
 "Action and Casual genere are the most common,relecting users . Preference for engaging and easy-to-play games")

fig.write_html('genre_counts_Graph 8.html')

from google.colab import files
files.download('genre_counts_Graph 8.html')

fig8.show()

#figure9
fig9=px.scatter(
    app_df,
    x='Last Updated',
    y='Rating',
    color ='Type',
    title='impact of Last Update on Rating',
    color_discrete_sequence=px.colors.qualitative.Vivid,
    width=400,
    height=300

)
fig9.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig9,'Update Graph 9.html',
 "The Scatter plot shows a weak correlation between the last update and ratings, suggesting that more frequent updates dont always result in better ratings ")

fig.write_html('Update_Graph 9.html')

from google.colab import files
files.download('Update_Graph 9.html')

fig9.show()

#figure10
fig10=px.box(
    app_df,
    x='Type',
    y='Rating',
    color ='Type',
    title='Rating for paid vs free Apps',
    color_discrete_sequence=px.colors.qualitative.Pastel1,
    width=400,
    height=300

)
fig10.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12} ),
    margin=dict(l=10,r=10,t=30,b=10)

)
save_plot_as_html(fig10,'Paid Free Graph 10.html',
 " Paid apps generally have higher ratings compared to free apps,suggesting that user except higher quality from apps they pay for")

fig.write_html('Paid_Free_Graph 10.html')

from google.colab import files
files.download('Paid_Free_Graph 10.html')

fig10.show()

plot_containers_split=plot_containers.split('</div>')

if len(plot_containers_split)>1:
  final_plot=plot_containers_split[-2]+'</div>'
else:
  final_plot=plot_containers

from IPython.display import HTML


dashboard_html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Google Play Store Review Analytics</title>
<style>
    body {{
        font-family: Arial, sans-serif;
        background-color: #333;
        color: #fff;
        margin: 0;
        padding: 0;
    }}
    .header {{
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
        background-color: #444;
    }}
    .header img {{
        margin: 0 10px;
        height: 50px;
    }}
    .header h1 {{
        margin: 0;
    }}
    .container {{
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        padding: 20px;
    }}
    .plot-container {{
        border: 2px solid #666;
        margin: 10px;
        width: 600px;
        height: 400px;
        position: relative;
        overflow: hidden;
        cursor: pointer;
        background-color: #222;
    }}
    .plot {{
        width: 100%;
        height: 100%;
    }}
    .insight {{
        display: none;
        position: absolute;
        right: 10px;
        top: 10px;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 5px 10px;
        border-radius: 5px;
        color: #fff;
        font-size: 14px;
    }}
    .plot-container:hover .insight {{
        display: block;
    }}
</style>
<script>
    function openplot(filename) {{
        window.open(filename, '_blank');
    }}
</script>
</head>
<body>
    <div class="header">
        <img src="https://upload.wikimedia.org/wikipedia/commons/7/78/Google_Play_Store_badge_EN.svg"
             alt="Google Play Logo">
        <h1>Google Play Store Review Analytics</h1>
    </div>
    <div class="container">
        {plot_containers}   <!-- ALL plots inserted here -->
    </div>
</body>
</html>
"""


HTML(dashboard_html)


with open("dashboard.html", "w", encoding="utf-8") as f:
    f.write(dashboard_html)


from google.colab import files
files.download("dashboard.html")

#Task 1
import pandas as pd
import plotly.express as px
from datetime import datetime
import pytz

filtered_df = app_df[
    (app_df["rating"] >= 4.0) &
    (app_df["size"] >= 10) &
    (app_df["last updated"].dt.month == 1)
]


category_stats = (
    filtered_df.groupby("category")
    .agg({"rating": "mean", "reviews": "sum", "installs": "sum"})
    .sort_values("installs", ascending=False)
    .head(10)
    .reset_index()
)


category_stats["Rating_scaled"] = category_stats["rating"] / category_stats["rating"].max() * 100
category_stats["Reviews_scaled"] = category_stats["reviews"] / category_stats["reviews"].max() * 100


ist = pytz.timezone("Asia/Kolkata")
current_time = datetime.now(ist).time()

def save_plot_as_html(fig, filename, description):
    with open(filename, "w") as f:
        f.write(fig.to_html(full_html=True, include_plotlyjs="cdn"))
        f.write(f"<p style='color:white; background:black; padding:10px;'>{description}</p>")

if 3 <= current_time.hour < 5 and not category_stats.empty:
    fig = px.bar(
        category_stats,
        x="category",
        y=["Rating_scaled", "Reviews_scaled"],
        barmode="group",
        title="Top 10 Categories: Avg Rating vs Total Reviews (Scaled for Comparison)",
        labels={"value": "Scaled Values (0‚Äì100)", "variable": "Metric"},
        color_discrete_sequence=["#1E90FF", "#FFD700"],
        width=900,
        height=500
    )

    fig.update_layout(
        plot_bgcolor="black",
        paper_bgcolor="black",
        font_color="white",
        margin=dict(l=10, r=10, t=40, b=10)
    )

    fig.show()

    save_plot_as_html(
        fig,
        "Category_Rating_Reviews_Bar.html",
        "üìä This grouped bar chart compares average ratings and total reviews (scaled 0‚Äì100) for the top 10 categories by installs. "
        "Only apps with Avg Rating ‚â• 4.0, Size ‚â• 10MB, updated in January are included. Visible only between 10AM‚Äì12PM IST."
    )
else:
    print("‚è≥ Chart hidden: Available only between 3AM‚Äì5PM IST.")

#task 2
import pandas as pd
from datetime import datetime
import pytz
import plotly.express as px

app_df.columns = app_df.columns.str.lower()
app_df["installs"] = app_df["installs"].astype(str).str.replace("[+,]", "", regex=True).astype(float)
app_df = app_df[~app_df["category"].str.upper().str.startswith(("A", "C", "G", "S"))]

top5_categories = app_df.groupby("category")["installs"].sum().nlargest(5).index
filtered_df = app_df[app_df["category"].isin(top5_categories)].copy()

if "country" not in filtered_df.columns:
    filtered_df["country"] = "USA"

filtered_df["highlight"] = filtered_df["installs"] > 1_000_000
global_installs = filtered_df.groupby(["country", "category"])["installs"].sum().reset_index()

ist = pytz.timezone("Asia/Kolkata")
current_time = datetime.now(ist).time()

if 18 <= current_time.hour < 20 and not global_installs.empty:
    fig = px.choropleth(
        global_installs,
        locations="country",
        locationmode="country names",
        color="installs",
        hover_name="category",
        animation_frame="category",
        color_continuous_scale="Viridis",
        title="Global Installs by Top 5 App Categories"
    )
    highlight_cats = global_installs[global_installs["installs"] > 1_000_000]["category"].unique()
    fig.update_layout(
        annotations=[
            dict(
                text=f"Highlighted Categories (>1M installs): {', '.join(highlight_cats)}",
                x=0.5, y=-0.1, showarrow=False, font=dict(size=12, color="white")
            )
        ],
        template="plotly_dark",
        geo=dict(showframe=False, showcoastlines=False)
    )
    fig.show()
else:
    print("‚è≥ Choropleth map hidden: Available only between 6 PM ‚Äì 8 PM IST.")

#task 3
from datetime import datetime
import pytz
import plotly.express as px
from plotly.subplots import make_subplots
import pandas as pd

data = {
    "app": ["PhotoPro", "BizMaster", "EduLearn", "FunPlay", "WorkSuite", "FreeNote", "ShopEase", "QuickTask"],
    "category": ["Photography", "Business", "Education", "Entertainment", "Business", "Education", "Shopping", "Education"],
    "type": ["Free", "Paid", "Free", "Paid", "Free", "Paid", "Free", "Paid"],
    "installs": [150000, 25000, 120000, 50000, 80000, 60000, 200000, 70000],
    "revenue": [50000, 150000, 80000, 100000, 95000, 120000, 70000, 110000],
    "android ver": [5.0, 6.0, 7.1, 5.1, 4.5, 6.0, 8.0, 5.0],
    "size": ["25M", "30M", "20M", "22M", "35M", "18M", "40M", "16M"],
    "content rating": ["Everyone", "Everyone", "Everyone", "Teen", "Everyone", "Everyone", "Everyone", "Everyone"]
}

app_df = pd.DataFrame(data)
app_df["size_clean"] = app_df["size"].str.replace("M", "").astype(float)

filtered_df = app_df[
    (app_df["installs"] >= 10000) &
    (app_df["revenue"] >= 10000) &
    (app_df["android ver"] > 4.0) &
    (app_df["size_clean"] > 15) &
    (app_df["content rating"] == "Everyone") &
    (app_df["app"].str.len() <= 30)
].copy()

top3_categories = filtered_df.groupby("category")["installs"].sum().nlargest(3).index
filtered_df = filtered_df[filtered_df["category"].isin(top3_categories)]

category_stats = filtered_df.groupby(["category", "type"]).agg({"installs": "mean", "revenue": "mean"}).reset_index()

def save_plot_as_html(fig, filename, description):
    with open(filename, "w") as f:
        f.write(fig.to_html(full_html=True, include_plotlyjs="cdn"))
        f.write(f"<p style='color:white; background:black; padding:10px;'>{description}</p>")

ist = pytz.timezone("Asia/Kolkata")
current_time = datetime.now(ist).time()

if 13 <= current_time.hour < 14 and not category_stats.empty:
    fig = make_subplots(specs=[[{"secondary_y": True}]])
    bar_fig = px.bar(
        category_stats,
        x="category",
        y="installs",
        color="type",
        barmode="group",
        labels={"installs": "Avg Installs"},
        color_discrete_sequence=px.colors.qualitative.Set2
    )
    line_fig = px.line(
        category_stats,
        x="category",
        y="revenue",
        color="type",
        markers=True,
        labels={"revenue": "Avg Revenue ($)"},
        color_discrete_sequence=px.colors.qualitative.Set1
    )
    for trace in bar_fig.data:
        fig.add_trace(trace, secondary_y=False)
    for trace in line_fig.data:
        fig.add_trace(trace, secondary_y=True)
    fig.update_layout(
        title="üìä Avg Installs vs Avg Revenue (Free vs Paid Apps in Top 3 Categories)",
        xaxis_title="Category",
        yaxis_title="Avg Installs",
        yaxis2_title="Avg Revenue ($)",
        plot_bgcolor="black",
        paper_bgcolor="black",
        font_color="white",
        legend=dict(orientation="h", y=-0.2),
        margin=dict(l=10, r=10, t=40, b=10)
    )
    fig.show()
    save_plot_as_html(
        fig,
        "Dual_Axis_Installs_Revenue.html",
        "üìà This dual-axis chart compares average installs and average revenue for Free vs Paid apps within the top 3 app categories. "
        "Only apps with Installs ‚â• 10K, Revenue ‚â• $10K, Android Ver > 4.0, Size > 15MB, and Content Rating = Everyone are included. "
        "Visible only between 1PM‚Äì2PM IST."
    )
else:
    print("‚è≥ Chart hidden: Available only between 1PM‚Äì2PM IST.")

from datetime import datetime
import pytz
import pandas as pd
import plotly.graph_objects as go

app_df.columns = app_df.columns.str.lower()

if "last updated" in app_df.columns:
    app_df["month"] = pd.to_datetime(app_df["last updated"], errors="coerce").dt.to_period("M")
elif "updated" in app_df.columns:
    app_df["month"] = pd.to_datetime(app_df["updated"], errors="coerce").dt.to_period("M")
else:
    app_df["month"] = pd.date_range(start="2024-01-01", periods=len(app_df), freq="M").to_period("M")

if "reviews" in app_df.columns:
    app_df = app_df[
        (~app_df["app"].str.lower().str.startswith(("x", "y", "z"))) &
        (~app_df["app"].str.contains("s", case=False)) &
        (app_df["category"].str.upper().str.startswith(("E", "C", "B"))) &
        (app_df["reviews"] > 500)
    ].copy()
else:
    app_df = app_df[
        (~app_df["app"].str.lower().str.startswith(("x", "y", "z"))) &
        (~app_df["app"].str.contains("s", case=False)) &
        (app_df["category"].str.upper().str.startswith(("E", "C", "B")))
    ].copy()

translations = {
    "Beauty": "‡§∏‡•å‡§Ç‡§¶‡§∞‡•ç‡§Ø",
    "Business": "‡Æµ‡Æ£‡Æø‡Æï‡ÆÆ‡Øç",
    "Dating": "Verabredung"
}
app_df["category_display"] = app_df["category"].replace(translations)

trend_df = app_df.groupby(["month", "category_display"])["installs"].sum().reset_index()
trend_df["pct_change"] = trend_df.groupby("category_display")["installs"].pct_change() * 100
trend_df["significant_growth"] = trend_df["pct_change"] > 20

ist = pytz.timezone("Asia/Kolkata")
current_time = datetime.now(ist).time()

if 18 <= current_time.hour < 21 and not trend_df.empty:
    fig = go.Figure()

    for cat in trend_df["category_display"].unique():
        cat_df = trend_df[trend_df["category_display"] == cat]
        fig.add_trace(go.Scatter(
            x=cat_df["month"].astype(str),
            y=cat_df["installs"],
            mode="lines+markers",
            name=cat
        ))
        growth_df = cat_df[cat_df["significant_growth"]]
        if not growth_df.empty:
            fig.add_trace(go.Scatter(
                x=growth_df["month"].astype(str),
                y=growth_df["installs"],
                fill='tozeroy',
                mode='none',
                name=f"{cat} (Significant Growth)",
                opacity=0.3
            ))

    fig.update_layout(
        title="üìà Total Installs Over Time (Significant Growth Highlighted)",
        xaxis_title="Month",
        yaxis_title="Total Installs",
        plot_bgcolor="black",
        paper_bgcolor="black",
        font_color="white",
        legend=dict(orientation="h", y=-0.2),
        margin=dict(l=10, r=10, t=40, b=10)
    )

    fig.show()

    with open("TimeSeries_Installs_Growth.html", "w", encoding="utf-8") as f:
        f.write(fig.to_html(full_html=True, include_plotlyjs="cdn"))
        f.write("<p style='color:white; background:black; padding:10px;'>"
                "üìä Time series chart showing total installs over time by app category. "
                "Shaded areas represent >20% month-over-month growth. "
                "Translations: Beauty ‚Üí ‡§∏‡•å‡§Ç‡§¶‡§∞‡•ç‡§Ø, Business ‚Üí ‡Æµ‡Æ£‡Æø‡Æï‡ÆÆ‡Øç, Dating ‚Üí Verabredung. "
                "Visible only between 6PM‚Äì9PM IST."
                "</p>")
else:
    print("‚è≥ Chart hidden: Available only between 6PM‚Äì9PM IST.")

#task4
import pandas as pd
import plotly.express as px
import numpy as np
from datetime import datetime
import pytz

def is_time_to_show_graph():
    """Checks if the current time in IST is between 5 PM and 7 PM."""
    try:
        ist = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist)
        start_time = now_ist.replace(hour=17, minute=0, second=0, microsecond=0)
        end_time = now_ist.replace(hour=19, minute=0, second=0, microsecond=0)
        return start_time <= now_ist <= end_time
    except Exception as e:
        print(f"An error occurred during time check: {e}")
        return False

def clean_play_store_data(df):
    """Cleans the Play Store dataframe."""
    df.dropna(subset=['Rating', 'Size', 'Installs', 'Category', 'Reviews'], inplace=True)

    df['Installs'] = df['Installs'].apply(lambda x: x.replace('+', '').replace(',', '')).astype(int)
    df['Reviews'] = pd.to_numeric(df['Reviews'], errors='coerce')
    df.dropna(subset=['Reviews'], inplace=True)
    df['Reviews'] = df['Reviews'].astype(int)

    def convert_size_to_mb(size):
        size = str(size)
        if 'M' in size:
            return float(size.replace('M', ''))
        elif 'k' in size:
            return float(size.replace('k', '')) / 1024
        elif 'Varies with device' in size:
            return np.nan
        else:
            return pd.to_numeric(size, errors='coerce')

    df['Size_MB'] = df['Size'].apply(convert_size_to_mb)
    df.dropna(subset=['Size_MB'], inplace=True)

    df['Category'] = df['Category'].str.upper()
    return df

def create_bubble_chart():
    """Loads, processes, and plots the app data if within the allowed time."""
    if not is_time_to_show_graph():
        ist = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist).strftime('%Y-%m-%d %H:%M:%S')
        print("This chart is only available to view between 5 PM and 7 PM IST.")
        print(f"Current IST is: {now_ist}")
        return

    try:
        play_store_df = pd.read_csv('Play Store Data.csv')
        user_reviews_df = pd.read_csv('User Reviews.csv')
    except FileNotFoundError as e:
        print(f"Error: {e}. Please ensure 'Play Store Data.csv' and 'User Reviews.csv' are in the correct directory.")
        return

    play_store_df = clean_play_store_data(play_store_df)

    # Calculate average subjectivity from user reviews
    reviews_agg = user_reviews_df.groupby('App')['Sentiment_Subjectivity'].mean().reset_index()
    df_merged = pd.merge(play_store_df, reviews_agg, on='App', how='inner')
    df_merged.dropna(subset=['Sentiment_Subjectivity'], inplace=True)

    categories_to_show = ['GAME', 'BEAUTY', 'BUSINESS', 'COMICS', 'COMMUNICATION', 'DATING', 'ENTERTAINMENT', 'SOCIAL', 'EVENTS']

    filtered_df = df_merged[
        (df_merged['Rating'] > 3.5) &
        (df_merged['Category'].isin(categories_to_show)) &
        (df_merged['Reviews'] > 500) &
        (~df_merged['App'].str.contains('S', case=False, na=False)) &
        (df_merged['Sentiment_Subjectivity'] > 0.5) &
        (df_merged['Installs'] > 50000)
    ].copy()

    if filtered_df.empty:
        print("No data matched the specified criteria. The chart cannot be generated.")
        return


    translation_map = {
        'BEAUTY': '‡§∏‡•å‡§Ç‡§¶‡§∞‡•ç‡§Ø (Beauty)',
        'BUSINESS': '‡Æµ‡Æ£‡Æø‡Æï‡ÆÆ‡Øç (Business)',
        'DATING': 'Dating (German)',
        'GAME': 'Game',
        'COMICS': 'Comics',
        'COMMUNICATION': 'Communication',
        'ENTERTAINMENT': 'Entertainment',
        'SOCIAL': 'Social',
        'EVENTS': 'Events'
    }
    filtered_df['Translated_Category'] = filtered_df['Category'].map(translation_map)


    color_map = {
        'Game': 'pink',
        '‡§∏‡•å‡§Ç‡§¶‡§∞‡•ç‡§Ø (Beauty)': px.colors.qualitative.Plotly[0],
        '‡Æµ‡Æ£‡Æø‡Æï‡ÆÆ‡Øç (Business)': px.colors.qualitative.Plotly[1],
        'Dating (German)': px.colors.qualitative.Plotly[2],
        'Comics': px.colors.qualitative.Plotly[3],
        'Communication': px.colors.qualitative.Plotly[4],
        'Entertainment': px.colors.qualitative.Plotly[5],
        'Social': px.colors.qualitative.Plotly[6],
        'Events': px.colors.qualitative.Plotly[7],
    }

    fig = px.scatter(
        filtered_df,
        x='Size_MB',
        y='Rating',
        size='Installs',
        color='Translated_Category',
        color_discrete_map=color_map,
        hover_name='App',
        log_x=True,
        size_max=60,
        title='App Analysis: Size vs. Rating (Filtered Bubble Chart)',
        labels={
            'Size_MB': 'App Size (MB)',
            'Rating': 'Average Rating',
            'Installs': 'Number of Installs',
            'Translated_Category': 'Category'
        }
    )

    fig.update_layout(
        xaxis_title='App Size (MB) - Log Scale',
        yaxis_title='Average Rating (1-5)',
        legend_title_text='App Category',
        title_font_size=20,
        title_x=0.5
    )


    chart_filename = 'app_bubble_chart.html'
    fig.write_html(chart_filename)
    print(f"Chart has been successfully saved as '{chart_filename}'")


if __name__ == '__main__':
    create_bubble_chart()

import pandas as pd
import plotly.express as px
import numpy as np
from datetime import datetime
import pytz

def is_time_to_show_graph():
    """Checks if the current time in IST is between 4 PM and 6 PM."""
    try:
        ist = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist)
        start_time = now_ist.replace(hour=16, minute=0, second=0, microsecond=0)
        end_time = now_ist.replace(hour=18, minute=0, second=0, microsecond=0)
        return start_time <= now_ist <= end_time
    except Exception as e:
        print(f"An error occurred during time check: {e}")
        return False

def clean_and_filter_data(df):
    """Cleans and filters the Play Store dataframe based on specific criteria."""
    df.dropna(subset=['Rating', 'Size', 'Installs', 'Category', 'Reviews', 'Last Updated'], inplace=True)

    df['Installs'] = df['Installs'].apply(lambda x: str(x).replace('+', '').replace(',', '')).astype(int)
    df['Reviews'] = pd.to_numeric(df['Reviews'], errors='coerce')
    df.dropna(subset=['Reviews'], inplace=True)
    df['Reviews'] = df['Reviews'].astype(int)

    df['Last Updated'] = pd.to_datetime(df['Last Updated'], errors='coerce')
    df.dropna(subset=['Last Updated'], inplace=True)

    def convert_size_to_mb(size):
        size = str(size)
        if 'M' in size:
            return float(size.replace('M', ''))
        elif 'k' in size:
            return float(size.replace('k', '')) / 1024
        elif 'Varies with device' in size:
            return np.nan
        else:
            return pd.to_numeric(size, errors='coerce')

    df['Size_MB'] = df['Size'].apply(convert_size_to_mb)
    df.dropna(subset=['Size_MB'], inplace=True)

    df['Category'] = df['Category'].str.upper()

    filtered_df = df[
        (df['Rating'] >= 4.2) &
        (~df['App'].str.contains(r'\d', na=False)) &
        (df['Category'].str.startswith(('T', 'P'))) &
        (df['Reviews'] > 1000) &
        (df['Size_MB'].between(20, 80))
    ].copy()

    return filtered_df

def create_stacked_area_chart():
    """Loads, processes, and plots the cumulative installs data."""
    try:
        play_store_df = pd.read_csv('Play Store Data.csv')
    except FileNotFoundError as e:
        print(f"Error: {e}. Please ensure 'Play Store Data.csv' is in the correct directory.")
        return

    filtered_df = clean_and_filter_data(play_store_df)

    if filtered_df.empty:
        print("No data matched the specified criteria. The chart cannot be generated.")
        return

    translation_map = {
        'TRAVEL_AND_LOCAL': 'Voyage et local (French)',
        'PRODUCTIVITY': 'Productividad (Spanish)',
        'PHOTOGRAPHY': 'ÂÜôÁúü (Japanese)'
    }

    filtered_df['Translated_Category'] = filtered_df['Category'].apply(lambda x: translation_map.get(x, x))

    filtered_df.sort_values('Last Updated', inplace=True)


    monthly_installs = filtered_df.groupby('Translated_Category').resample('M', on='Last Updated')['Installs'].sum()
    monthly_pct_change = monthly_installs.groupby('Translated_Category').pct_change()
    highlight_dates = monthly_pct_change[monthly_pct_change > 0.25].reset_index()['Last Updated'].unique()

    filtered_df['Cumulative Installs'] = filtered_df.groupby('Translated_Category')['Installs'].cumsum()

    fig = px.area(
        filtered_df,
        x='Last Updated',
        y='Cumulative Installs',
        color='Translated_Category',
        title='Cumulative App Installs Over Time by Category',
        labels={
            'Last Updated': 'Date',
            'Cumulative Installs': 'Cumulative Number of Installs',
            'Translated_Category': 'Category'
        }
    )


    for date in highlight_dates:
        fig.add_vline(x=date, line_width=1.5, line_dash="dash", line_color="red",
                      annotation_text=f"Growth >25%", annotation_position="top left",
                      annotation_font_size=10)

    fig.update_layout(
        legend_title_text='App Category',
        title_font_size=20,
        title_x=0.5
    )


    chart_filename = 'app_installs_chart.html'
    fig.write_html(chart_filename)
    print(f"Chart has been successfully saved as '{chart_filename}'")


if __name__ == '__main__':
    if is_time_to_show_graph():
        create_stacked_area_chart()
    else:
        ist = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist).strftime('%Y-%m-%d %H:%M:%S')
        print(f"This chart is only available to view between 4 PM and 6 PM IST. Current IST is: {now_ist}")